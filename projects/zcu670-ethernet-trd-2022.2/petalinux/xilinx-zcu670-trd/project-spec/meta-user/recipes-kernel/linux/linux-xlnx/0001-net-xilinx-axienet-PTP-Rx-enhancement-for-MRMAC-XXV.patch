From 0ec1328a1080771709a3766667a688412267bf11 Mon Sep 17 00:00:00 2001
From: Sarath Babu Naidu Gaddam <sarath.babu.naidu.gaddam@amd.com>
Date: Mon, 12 Apr 2021 01:52:32 -0600
Subject: [LINUX PATCH 1/3] net: xilinx: axienet: PTP Rx enhancement for MRMAC
 & XXV

New HW design logic prefixes timestamp values to data stream and
only updates the qualifier bit for L2 PTP and UDP IPV4 PTP packets.

Update SW driver to support this mechanism to extract SW timestamp
and discard the prefix 16 bytes for non-PTP packets before passing
information to higher layers as usual.

Signed-off-by: Sarath Babu Naidu Gaddam <sarath.babu.naidu.gaddam@amd.com>
---
 .../net/ethernet/xilinx/xilinx_axienet_main.c | 104 +++++++-----------
 1 file changed, 41 insertions(+), 63 deletions(-)

diff --git a/drivers/net/ethernet/xilinx/xilinx_axienet_main.c b/drivers/net/ethernet/xilinx/xilinx_axienet_main.c
index 3742284ece9e..8a17dbf377b1 100644
--- a/drivers/net/ethernet/xilinx/xilinx_axienet_main.c
+++ b/drivers/net/ethernet/xilinx/xilinx_axienet_main.c
@@ -67,6 +67,8 @@
 #define NS_PER_SEC              1000000000ULL /* Nanoseconds per second */
 
 #define MRMAC_RESET_DELAY	1 /* Delay in msecs*/
+#define TSTAMP_LEN		16
+#define QUALIFIER		BIT(31)
 
 /* IEEE1588 Message Type field values  */
 #define PTP_TYPE_SYNC		0
@@ -602,16 +604,29 @@ static int axienet_device_reset(struct net_device *ndev)
 #endif
 		}
 
-	lp->max_frm_size = XAE_MAX_VLAN_FRAME_SIZE;
+	/*Accommodate 16 byte TS header prefixed in datastream*/
+	if (lp->axienet_config->mactype == XAXIENET_MRMAC ||
+			lp->axienet_config->mactype == XAXIENET_10G_25G)
+		lp->max_frm_size = XAE_MAX_VLAN_FRAME_SIZE + TSTAMP_LEN;
+	else
+		lp->max_frm_size = XAE_MAX_VLAN_FRAME_SIZE;
+
+
 	if (lp->axienet_config->mactype != XAXIENET_10G_25G &&
 	    lp->axienet_config->mactype != XAXIENET_MRMAC) {
 		lp->options |= XAE_OPTION_VLAN;
 		lp->options &= (~XAE_OPTION_JUMBO);
 	}
 
-	if (ndev->mtu > XAE_MTU && ndev->mtu <= XAE_JUMBO_MTU) {
-		lp->max_frm_size = ndev->mtu + VLAN_ETH_HLEN +
-					XAE_TRL_SIZE;
+	if ((ndev->mtu > XAE_MTU) && (ndev->mtu <= XAE_JUMBO_MTU)) {
+		/*Accommodate 16 byte TS header prefixed in datastream*/
+		if (lp->axienet_config->mactype == XAXIENET_MRMAC ||
+				lp->axienet_config->mactype == XAXIENET_10G_25G)
+			lp->max_frm_size = ndev->mtu + VLAN_ETH_HLEN +
+						XAE_TRL_SIZE + TSTAMP_LEN;
+		else
+			lp->max_frm_size = ndev->mtu + VLAN_ETH_HLEN +
+						XAE_TRL_SIZE;
 		if (lp->max_frm_size <= lp->rxmem &&
 		    (lp->axienet_config->mactype != XAXIENET_10G_25G &&
 		     lp->axienet_config->mactype != XAXIENET_MRMAC))
@@ -875,62 +890,6 @@ static inline bool is_ptp_os_pdelay_req(struct sk_buff *skb,
 	return (((*msg_type & 0xF) == PTP_TYPE_PDELAY_REQ) &&
 		(lp->tstamp_config.tx_type == HWTSTAMP_TX_ONESTEP_P2P));
 }
-
-/**
- * axienet_rx_hwtstamp - Read rx timestamp from hw and update it to the skbuff
- * @lp:		Pointer to axienet local structure
- * @skb:	Pointer to the sk_buff structure
- *
- * Return:	None.
- */
-static void axienet_rx_hwtstamp(struct axienet_local *lp,
-				struct sk_buff *skb)
-{
-	u32 sec = 0, nsec = 0, val;
-	u64 time64;
-	int err = 0;
-	struct skb_shared_hwtstamps *shhwtstamps = skb_hwtstamps(skb);
-
-	val = axienet_rxts_ior(lp, XAXIFIFO_TXTS_ISR);
-	if (unlikely(!(val & XAXIFIFO_TXTS_INT_RC_MASK))) {
-		dev_info(lp->dev, "Did't get FIFO rx interrupt %d\n", val);
-		return;
-	}
-
-	val = axienet_rxts_ior(lp, XAXIFIFO_TXTS_RFO);
-	if (!val)
-		return;
-
-	/* If FIFO is configured in cut through Mode we will get Rx complete
-	 * interrupt even one byte is there in the fifo wait for the full packet
-	 */
-	err = readl_poll_timeout_atomic(lp->rx_ts_regs + XAXIFIFO_TXTS_RLR, val,
-					((val & XAXIFIFO_TXTS_RXFD_MASK) >= 12),
-					0, 1000000);
-	if (err) {
-		netdev_err(lp->ndev, "%s: Didn't get the full timestamp packet",
-			   __func__);
-		return;
-	}
-
-	nsec = axienet_rxts_ior(lp, XAXIFIFO_TXTS_RXFD);
-	sec  = axienet_rxts_ior(lp, XAXIFIFO_TXTS_RXFD);
-	val = axienet_rxts_ior(lp, XAXIFIFO_TXTS_RXFD);
-
-	if (is_ptp_os_pdelay_req(skb, lp)) {
-		/* Need to save PDelay resp RX time for HW 1 step
-		 * timestamping on PDelay Response.
-		 */
-		lp->ptp_os_cf = mul_u32_u32(sec, NSEC_PER_SEC);
-		lp->ptp_os_cf += nsec;
-		lp->ptp_os_cf = (lp->ptp_os_cf << 16);
-	}
-
-	if (lp->tstamp_config.rx_filter == HWTSTAMP_FILTER_ALL) {
-		time64 = sec * NS_PER_SEC + nsec;
-		shhwtstamps->hwtstamp = ns_to_ktime(time64);
-	}
-}
 #endif
 
 /**
@@ -1564,9 +1523,28 @@ static int axienet_recv(struct net_device *ndev, int budget,
 			time64 = sec * NS_PER_SEC + nsec;
 			shhwtstamps = skb_hwtstamps(skb);
 			shhwtstamps->hwtstamp = ns_to_ktime(time64);
-		} else if (lp->axienet_config->mactype == XAXIENET_10G_25G ||
-			   lp->axienet_config->mactype == XAXIENET_MRMAC) {
-			axienet_rx_hwtstamp(lp, skb);
+		} else if (lp->axienet_config->mactype == XAXIENET_MRMAC ||
+					lp->axienet_config->mactype == XAXIENET_10G_25G) {
+			u32 sec, nsec, sech;
+			u64 time64;
+			struct skb_shared_hwtstamps *shhwtstamps;
+
+			/* [31]:Qual bit; [15:0]: Resvd; [16:0]: TS[79:64] */
+			memcpy(&sech, &skb->data[8], 4);
+
+			if (sech & QUALIFIER) {
+				/* 80 bit timestamp */
+				memcpy(&nsec, &skb->data[0], 4);
+				memcpy(&sec, &skb->data[4], 4);
+			}
+
+			skb_pull(skb, 16);
+
+			if (sech & QUALIFIER) {
+				time64 = sec * NS_PER_SEC + nsec;
+				shhwtstamps = skb_hwtstamps(skb);
+				shhwtstamps->hwtstamp = ns_to_ktime(time64);
+			}
 		}
 #endif
 		skb->protocol = eth_type_trans(skb, ndev);
-- 
2.25.1

