From 7ed9b8b4b4a51693261bb65d273a13eb84165e4c Mon Sep 17 00:00:00 2001
From: Sarath Babu Naidu Gaddam <sarath.babu.naidu.gaddam@amd.com>
Date: Wed, 16 Jun 2021 01:29:49 -0600
Subject: [LINUX PATCH 3/3] net: xilinx: axienet: Remove FIFO related code for
 MRMAC & XXV

Updated MRMAC and XXV subsystems in TRD do not use FIFOs.
TX timestamps are part of the MM2S user app descriptor fields
and RX timestamps are in band within the datastream.

As there's no TS FIFOs, one step HW timestamping support based
on that is also removed for MRMAC. Enhanced PTP logic currently supports
only 2 step PTP.

Signed-off-by: Sarath Babu Naidu Gaddam <sarath.babu.naidu.gaddam@amd.com>
---
 drivers/net/ethernet/xilinx/xilinx_axienet.h  |   5 -
 .../net/ethernet/xilinx/xilinx_axienet_main.c | 101 ++----------------
 .../ethernet/xilinx/xilinx_axienet_mcdma.c    |  14 ---
 3 files changed, 11 insertions(+), 109 deletions(-)

diff --git a/drivers/net/ethernet/xilinx/xilinx_axienet.h b/drivers/net/ethernet/xilinx/xilinx_axienet.h
index 6d01ed2ff32b..a141fe37ba79 100644
--- a/drivers/net/ethernet/xilinx/xilinx_axienet.h
+++ b/drivers/net/ethernet/xilinx/xilinx_axienet.h
@@ -707,7 +707,6 @@ struct aximcdma_bd {
  * @ptp_txq:	PTP tx queue header
  * @tx_tstamp_work: PTP timestamping work queue
  * @qbv_regs:	pointer to qbv registers base address
- * @ptp_tx_lock: PTP tx lock
  * @dma_err_tasklet: Tasklet structure to process Axi DMA errors
  * @eth_irq:	Axi Ethernet IRQ number
  * @options:	AxiEthernet option word
@@ -731,7 +730,6 @@ struct aximcdma_bd {
  * @tx_ts_regs:	  Base address for the axififo device address space.
  * @rx_ts_regs:	  Base address for the rx axififo device address space.
  * @tstamp_config: Hardware timestamp config structure.
- * @tx_ptpheader: Stores the tx ptp header.
  * @aclk: AXI4-Lite clock for ethernet and dma.
  * @eth_sclk: AXI4-Stream interface clock.
  * @eth_refclk: Stable clock used by signal delay primitives and transceivers.
@@ -778,7 +776,6 @@ struct axienet_local {
 
 	phy_interface_t phy_mode;
 
-	spinlock_t ptp_tx_lock;		/* PTP tx lock*/
 	int eth_irq;
 
 	u32 options;			/* Current options word */
@@ -805,7 +802,6 @@ struct axienet_local {
 	void __iomem *tx_ts_regs;
 	void __iomem *rx_ts_regs;
 	struct hwtstamp_config tstamp_config;
-	u8 *tx_ptpheader;
 #endif
 	struct clk *aclk;
 	struct clk *eth_sclk;
@@ -935,7 +931,6 @@ struct axienet_config {
 			struct clk **axis_clk, struct clk **ref_clk,
 			struct clk **dclk);
 	u32 tx_ptplen;
-	u8 ts_header_len;
 };
 
 /**
diff --git a/drivers/net/ethernet/xilinx/xilinx_axienet_main.c b/drivers/net/ethernet/xilinx/xilinx_axienet_main.c
index ecfdc6c41e2c..a0f31d344fae 100644
--- a/drivers/net/ethernet/xilinx/xilinx_axienet_main.c
+++ b/drivers/net/ethernet/xilinx/xilinx_axienet_main.c
@@ -61,9 +61,6 @@
 
 #define AXIENET_REGS_N		40
 #define AXIENET_TS_HEADER_LEN	8
-#define XXVENET_TS_HEADER_LEN	4
-#define MRMAC_TS_HEADER_LEN		16
-#define MRMAC_TS_HEADER_WORDS   (MRMAC_TS_HEADER_LEN / 4)
 #define NS_PER_SEC              1000000000ULL /* Nanoseconds per second */
 
 #define MRMAC_RESET_DELAY	1 /* Delay in msecs*/
@@ -672,33 +669,9 @@ static int axienet_device_reset(struct net_device *ndev)
 					 10, DELAY_OF_ONE_MILLISEC);
 		if (err)
 			netdev_err(ndev, "XXV MAC block lock not complete! Cross-check the MAC ref clock configuration\n");
-
-#ifdef CONFIG_XILINX_AXI_EMAC_HWTSTAMP
-			axienet_rxts_iow(lp, XAXIFIFO_TXTS_RDFR,
-					 XAXIFIFO_TXTS_RESET_MASK);
-			axienet_rxts_iow(lp, XAXIFIFO_TXTS_SRR,
-					 XAXIFIFO_TXTS_RESET_MASK);
-			axienet_txts_iow(lp, XAXIFIFO_TXTS_RDFR,
-					 XAXIFIFO_TXTS_RESET_MASK);
-			axienet_txts_iow(lp, XAXIFIFO_TXTS_SRR,
-					 XAXIFIFO_TXTS_RESET_MASK);
-#endif
-	}
-
-#ifdef CONFIG_XILINX_AXI_EMAC_HWTSTAMP
-	if (lp->axienet_config->mactype == XAXIENET_MRMAC) {
-		axienet_rxts_iow(lp, XAXIFIFO_TXTS_RDFR,
-				 XAXIFIFO_TXTS_RESET_MASK);
-		axienet_rxts_iow(lp, XAXIFIFO_TXTS_SRR,
-				 XAXIFIFO_TXTS_RESET_MASK);
-		axienet_txts_iow(lp, XAXIFIFO_TXTS_RDFR,
-				 XAXIFIFO_TXTS_RESET_MASK);
-		axienet_txts_iow(lp, XAXIFIFO_TXTS_SRR,
-				 XAXIFIFO_TXTS_RESET_MASK);
 	}
-#endif
 
-	if (lp->axienet_config->mactype == XAXIENET_1G &&
+	if ((lp->axienet_config->mactype == XAXIENET_1G) &&
 	    !lp->eth_hasnobuf) {
 		axienet_status = axienet_ior(lp, XAE_IP_OFFSET);
 		if (axienet_status & XAE_INT_RXRJECT_MASK)
@@ -863,17 +836,13 @@ void axienet_tx_hwtstamp(struct axienet_local *lp,
 		}
 	}
 
-	if (lp->axienet_config->mactype != XAXIENET_10G_25G &&
-	    lp->axienet_config->mactype != XAXIENET_MRMAC)
 		val = axienet_txts_ior(lp, XAXIFIFO_TXTS_RXFD);
 
 skb_exit:
 	time64 = sec * NS_PER_SEC + nsec;
 	memset(shhwtstamps, 0, sizeof(struct skb_shared_hwtstamps));
 	shhwtstamps->hwtstamp = ns_to_ktime(time64);
-	if (lp->axienet_config->mactype != XAXIENET_10G_25G &&
-	    lp->axienet_config->mactype != XAXIENET_MRMAC)
-		skb_pull((struct sk_buff *)cur_p->ptp_tx_skb,
+	skb_pull((struct sk_buff *)cur_p->ptp_tx_skb,
 			 AXIENET_TS_HEADER_LEN);
 
 	skb_tstamp_tx((struct sk_buff *)cur_p->ptp_tx_skb, shhwtstamps);
@@ -1074,9 +1043,6 @@ static int axienet_create_tsheader(u8 *buf, u8 msg_type,
 	struct axidma_bd *cur_p;
 #endif
 	u64 val;
-	u32 tmp[MRMAC_TS_HEADER_WORDS];
-	unsigned long flags;
-	int i;
 
 #ifdef CONFIG_AXIENET_HAS_MCDMA
 	cur_p = &q->txq_bd_v[q->tx_bd_tail];
@@ -1087,33 +1053,11 @@ static int axienet_create_tsheader(u8 *buf, u8 msg_type,
 	if ((msg_type & 0xF) == TX_TS_OP_NOOP) {
 		buf[0] = TX_TS_OP_NOOP;
 	} else if ((msg_type & 0xF) == TX_TS_OP_ONESTEP) {
-		if (lp->axienet_config->mactype == XAXIENET_MRMAC) {
-			/* For Sync Packet */
-			if ((msg_type & 0xF0) == MSG_TYPE_SYNC_FLAG) {
-				buf[0] = TX_TS_OP_ONESTEP | TX_TS_CSUM_UPDATE_MRMAC;
-				buf[2] = cur_p->ptp_tx_ts_tag & 0xFF;
-				buf[3] = (cur_p->ptp_tx_ts_tag >> 8) & 0xFF;
-				buf[4] = TX_PTP_CF_OFFSET;
-				buf[6] = TX_PTP_CSUM_OFFSET;
-			}
-			/* For PDelay Response packet */
-			if ((msg_type & 0xF0) == MSG_TYPE_PDELAY_RESP_FLAG) {
-				buf[0] = TX_TS_OP_ONESTEP | TX_TS_CSUM_UPDATE_MRMAC |
-					TX_TS_PDELAY_UPDATE_MRMAC;
-				buf[2] = cur_p->ptp_tx_ts_tag & 0xFF;
-				buf[3] = (cur_p->ptp_tx_ts_tag >> 8) & 0xFF;
-				buf[4] = TX_PTP_CF_OFFSET;
-				buf[6] = TX_PTP_CSUM_OFFSET;
-				/* Prev saved TS */
-				memcpy(&buf[8], &lp->ptp_os_cf, 8);
-			}
-		} else {
 			/* Legacy */
 			buf[0] = TX_TS_OP_ONESTEP;
 			buf[1] = TX_TS_CSUM_UPDATE;
 			buf[4] = TX_PTP_TS_OFFSET;
 			buf[6] = TX_PTP_CSUM_OFFSET;
-		}
 	} else {
 		buf[0] = TX_TS_OP_TWOSTEP;
 		buf[2] = cur_p->ptp_tx_ts_tag & 0xFF;
@@ -1125,21 +1069,6 @@ static int axienet_create_tsheader(u8 *buf, u8 msg_type,
 		memcpy(&val, buf, AXIENET_TS_HEADER_LEN);
 		swab64s(&val);
 		memcpy(buf, &val, AXIENET_TS_HEADER_LEN);
-	} else if (lp->axienet_config->mactype == XAXIENET_10G_25G ||
-		   lp->axienet_config->mactype == XAXIENET_MRMAC) {
-		memcpy(&tmp[0], buf, lp->axienet_config->ts_header_len);
-		/* Check for Transmit Data FIFO Vacancy */
-		spin_lock_irqsave(&lp->ptp_tx_lock, flags);
-		if (!axienet_txts_ior(lp, XAXIFIFO_TXTS_TDFV)) {
-			spin_unlock_irqrestore(&lp->ptp_tx_lock, flags);
-			return NETDEV_TX_BUSY;
-		}
-
-		for (i = 0; i < lp->axienet_config->ts_header_len / 4; i++)
-			axienet_txts_iow(lp, XAXIFIFO_TXTS_TXFD, tmp[i]);
-
-		axienet_txts_iow(lp, XAXIFIFO_TXTS_TLR, lp->axienet_config->ts_header_len);
-		spin_unlock_irqrestore(&lp->ptp_tx_lock, flags);
 	}
 
 	return 0;
@@ -1183,9 +1112,9 @@ static int axienet_skb_tstsmp(struct sk_buff **__skb, struct axienet_dma_q *q,
 
 	if (((lp->tstamp_config.tx_type == HWTSTAMP_TX_ONESTEP_SYNC ||
 	      lp->tstamp_config.tx_type == HWTSTAMP_TX_ON) ||
-	       lp->eth_hasptp) && lp->axienet_config->mactype !=
+	       lp->eth_hasptp) && (lp->axienet_config->mactype !=
 	       XAXIENET_10G_25G &&
-	       lp->axienet_config->mactype != XAXIENET_MRMAC) {
+	       lp->axienet_config->mactype != XAXIENET_MRMAC)) {
 		u8 *tmp;
 		struct sk_buff *new_skb;
 
@@ -3089,7 +3018,6 @@ static const struct axienet_config axienet_10g25g_config = {
 	.setoptions = xxvenet_setoptions,
 	.clk_init = xxvenet_clk_init,
 	.tx_ptplen = XXV_TX_PTP_LEN,
-	.ts_header_len = XXVENET_TS_HEADER_LEN,
 };
 
 static const struct axienet_config axienet_usxgmii_config = {
@@ -3104,7 +3032,6 @@ static const struct axienet_config axienet_mrmac_config = {
 	.setoptions = xxvenet_setoptions,
 	.clk_init = xxvenet_clk_init,
 	.tx_ptplen = XXV_TX_PTP_LEN,
-	.ts_header_len = MRMAC_TS_HEADER_LEN,
 };
 
 /* Match table for of_platform binding */
@@ -3152,9 +3079,6 @@ static int axienet_probe(struct platform_device *pdev)
 	struct resource *ethres;
 	u32 value;
 	u16 num_queues = XAE_MAX_QUEUES;
-#ifdef CONFIG_XILINX_AXI_EMAC_HWTSTAMP
-	struct resource txtsres, rxtsres;
-#endif
 
 	ret = of_property_read_u16(pdev->dev.of_node, "xlnx,num-queues",
 				   &num_queues);
@@ -3393,9 +3317,13 @@ static int axienet_probe(struct platform_device *pdev)
 	}
 
 #ifdef CONFIG_XILINX_AXI_EMAC_HWTSTAMP
+	if (lp->axienet_config->mactype != XAXIENET_MRMAC &&
+			lp->axienet_config->mactype != XAXIENET_10G_25G) {
+		struct resource txtsres, rxtsres;
+
 		/* Find AXI Stream FIFO */
 		np = of_parse_phandle(pdev->dev.of_node, "axififo-connected",
-				      0);
+				0);
 		if (IS_ERR(np)) {
 			dev_err(&pdev->dev, "could not find TX Timestamp FIFO\n");
 			ret = PTR_ERR(np);
@@ -3405,7 +3333,7 @@ static int axienet_probe(struct platform_device *pdev)
 		ret = of_address_to_resource(np, 0, &txtsres);
 		if (ret) {
 			dev_err(&pdev->dev,
-				"unable to get Tx Timestamp resource\n");
+					"unable to get Tx Timestamp resource\n");
 			goto free_netdev;
 		}
 
@@ -3416,8 +3344,6 @@ static int axienet_probe(struct platform_device *pdev)
 			goto free_netdev;
 		}
 
-		if (lp->axienet_config->mactype == XAXIENET_10G_25G ||
-		    lp->axienet_config->mactype == XAXIENET_MRMAC) {
 			np = of_parse_phandle(pdev->dev.of_node,
 					      "xlnx,rxtsfifo", 0);
 			if (IS_ERR(np)) {
@@ -3443,13 +3369,8 @@ static int axienet_probe(struct platform_device *pdev)
 				goto free_netdev;
 			}
 
-			lp->tx_ptpheader = devm_kzalloc(&pdev->dev,
-							lp->axienet_config->ts_header_len,
-							GFP_KERNEL);
-			spin_lock_init(&lp->ptp_tx_lock);
-		}
-
 		of_node_put(np);
+	}
 #endif
 	if (lp->axienet_config->mactype == XAXIENET_10G_25G)
 		lp->xxv_ip_version = axienet_ior(lp, XXV_CONFIG_REVISION);
diff --git a/drivers/net/ethernet/xilinx/xilinx_axienet_mcdma.c b/drivers/net/ethernet/xilinx/xilinx_axienet_mcdma.c
index b96da65b2051..e533cfbc3036 100644
--- a/drivers/net/ethernet/xilinx/xilinx_axienet_mcdma.c
+++ b/drivers/net/ethernet/xilinx/xilinx_axienet_mcdma.c
@@ -717,20 +717,6 @@ void __maybe_unused axienet_mcdma_err_handler(unsigned long data)
 	    lp->axienet_config->mactype != XAXIENET_MRMAC)
 		axienet_iow(lp, XAE_FCC_OFFSET, XAE_FCC_FCRX_MASK);
 
-#ifdef CONFIG_XILINX_AXI_EMAC_HWTSTAMP
-	if (lp->axienet_config->mactype == XAXIENET_10G_25G ||
-	    lp->axienet_config->mactype == XAXIENET_MRMAC) {
-		axienet_rxts_iow(lp, XAXIFIFO_TXTS_RDFR,
-				 XAXIFIFO_TXTS_RESET_MASK);
-		axienet_rxts_iow(lp, XAXIFIFO_TXTS_SRR,
-				 XAXIFIFO_TXTS_RESET_MASK);
-		axienet_txts_iow(lp, XAXIFIFO_TXTS_RDFR,
-				 XAXIFIFO_TXTS_RESET_MASK);
-		axienet_txts_iow(lp, XAXIFIFO_TXTS_SRR,
-				 XAXIFIFO_TXTS_RESET_MASK);
-	}
-#endif
-
 	lp->axienet_config->setoptions(ndev, lp->options &
 				       ~(XAE_OPTION_TXEN | XAE_OPTION_RXEN));
 	axienet_set_mac_address(ndev, NULL);
-- 
2.25.1

